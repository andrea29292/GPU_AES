\chapter{Advanced Encryption Standard (AES)}

\section{Caratteristiche}
Sviluppato dai due crittografi belgi Joan Daemen e Vincent Rijmen l'Advanced Encryption Standard (AES), conosciuto anche come Rijndael, di cui più propriamente è una specifica implementazione, è un algoritmo di cifratura a blocchi utilizzato come standard dal governo degli Stati Uniti d'America. 

\paragraph{}
Data la sua sicurezza e le sue specifiche pubbliche si presume che in un prossimo futuro venga utilizzato in tutto il mondo come è successo al suo predecessore, il Data Encryption Standard (DES) che ha perso poi efficacia per vulnerabilità intrinseche. AES è stato adottato dalla National Institute of Standards and Technology (NIST) e dalla US FIPS PUB nel novembre del 2001 dopo 5 anni di studi, standardizzazioni e selezione finale tra i vari algoritmi proposti.

\subsection{ La chiave di sessione}
AES  usa un \textbf{key schedule} per espandere una chiave primaria corta in un certo numero di chiavi di \textbf{ciclo} differenti. 

\subsection{Lo stato}
AES opera utilizzando matrici di 4x4 byte chiamate \textbf{stati}. Quando l'algoritmo ha blocchi di 128 bit in input, la matrice di stato ha 4 righe e 4 colonne; se il numero di blocchi in input diventa di 32 bit più lungo, viene aggiunta una colonna allo stato, e così via fino a 256 bit. In pratica, si divide il numero di bit del blocco in input per 32 e il quoziente specifica il numero di colonne.

\section{Descrizione dell'algoritmo}
L'algoritmo sfrutta diverse funzioni che modificano i valori della matrice di stato mantenendone però la dimensione. Le singole funzioni vengono poi ripetute in un certo ordine per costruire l'algoritmo vero e proprio.

\subsection{Descrizione ad alto livello}
KeyExpansions—round keys are derived from the cipher key using Rijndael's key schedule. AES requires a separate 128-bit round key block for each round plus one more.
InitialRound
AddRoundKey—each byte of the state is combined with a block of the round key using bitwise xor.
Rounds
SubBytes—a non-linear substitution step where each byte is replaced with another according to a lookup table.
ShiftRows—a transposition step where the last three rows of the state are shifted cyclically a certain number of steps.
MixColumns—a mixing operation which operates on the columns of the state, combining the four bytes in each column.
AddRoundKey
Final Round (no MixColumns)
SubBytes
ShiftRows
AddRoundKey.

\begin{enumerate}
\item \textbf{KeyExpansions} La chiave di cifratura viene espansa dal key schedule per generare una chiave più grande contenente tutte le chiavi di ciclo.
\item \textbf{Round iniziale}
\begin{enumerate}
\item \textit{AddRoundKey} Ogni byte dello stato viene combinato con il byte corrispondente della chiave di ciclo tramite uno XOR
\end{enumerate}
\item \textbf{Rounds}
\begin{enumerate}
\item \textit{SubBytes} Ogni byte viene sostituito con un altro secondo delle tabelle.
\item \textit{ShiftRows} Una trasposizione dove le ultime tre righe dello stato sono shiftate a sinistra un certo numero di volte.
\item \textit{MixColumns} Opera sulle colonne combinandone i byte.
\item \textit{AddRoundKey}
\end{enumerate}
\item \textbf{Round Finale (senza MixColumns)}
\begin{enumerate}
\item \textit{SubBytes}
\item \textit{ShiftRows}
\item \textit{AddRoundKey}
\end{enumerate}
\end{enumerate}




\subsection{AddRoundKey}
Nella fase AddRoundKey, la chiave di sessione viene combinata con lo stato. Per ogni round viene derivata una sottochiave dalla chiave originaria usando il key schedule; ogni sottochiave è della stessa dimensione dello stato. La sottochiave è aggiunta allo stato combinando ogni byte di questo con il corrispondente byte della chiave con uno \textbf{XOR}. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{img/addroundkey}
\caption{Nel passaggio AddRoundKeys ogni byte della matrice viene combinato con la sua sottochiave tramite un'operazione di XOR.}
\end{figure}

\subsection{SubBytes}
In SubBytes ogni byte \(a_{i,j}\) della matrice di stato è sostituito con il corrispondente byte di una matrice chiamata  \textbf{S-box}.
\begin{center}
\(b_{i,j} = S(a_{i,j})\)
\end{center}

Questa operazione garantisce la non-linearità della cifratura. 
La S-box utilizzata è derivata da una funzione inversa nel campo finito GF(\(2^8\)), conosciuta per avere delle ottime proprietà di non linearità. Per evitare un potenziale attacco basato sulle proprietà algebriche la S-box è costruita combinando la funzione inversa con una trasformazione affine invertibile. La S-box è stata scelta con cura per non possedere né punti fissi né punti fissi opposti.

\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{img/subBytes}
\caption{Nel passaggio SubBytes, ogni byte della matrice è sostituito con i dati contenuti nella trasformazione S; \(b_{ij} = S(a_{ij})\).}
\end{figure}

\subsection{ShiftRows}
ShiftRows opera sulle righe dello stato shiftando ciclicamente i byte di ogni riga di un certo offset dipendente dal numero di riga lasciando la prima riga invariata.
Ogni byte della seconda riga è ciclicamente spostato a sinistra di una posizione. Similmente i byte della terza riga sono shiftati ciclicamente a sinistra di due posizioni e quelli della quarta di tre. 

In questo modo l'ultima colonna dei dati in ingresso andrà a formare la diagonale della matrice in uscita. (Rijndael utilizza un disegno leggermente diverso per via delle matrici di lunghezza non fissa.)


\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{img/shiftRows}
\caption{Nel passaggio ShiftRows, i byte di ogni riga vengono spostati verso sinistra dell'ordine della riga. Vedi figura per i singoli spostamenti.}
\end{figure}

\subsection{MixColumns}
Il passaggio MixColumns prende i quattro byte di ogni colonna e li combina utilizzando una trasformazione lineare invertibile. Utilizzati in congiunzione, ShiftRows e MixColumns provvedono a far rispettare il criterio di confusione e diffusione nell'algoritmo (teoria di Shannon). Ogni colonna è trattata come un polinomio in \(GF(2^8)\) e viene moltiplicata modulo \(x^4+1\) per un polinomio fisso \(c(x)=3x^3+x^2+x+2\).

\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{img/mixColumns}
\caption{Nel passaggio MixColumns ogni colonna di byte viene moltiplicata per un polinomio fisso \(c(x)\).}
\end{figure}
